# Лабораторні роботи з дисципліни "Алгоритмів і структур даних"

## Виконав: Рибак Денис Ігорович (Група ІР-24)

### Лабораторна робота №1 (Варіант 1 Рівень 1)

'''
   Дані два масиви цілих чисел `nums1` і `nums2`, де `nums1` є підмасивом `nums2`, якщо всі елементи `nums1` знаходяться в `nums2`, в тому ж порядку.
​
   Напишіть функцію `is_subarray`, яка приймає два масиви цілих чисел та повертає `True`, якщо `nums1` є підмасивом `nums2`, та `False` в іншому випадку.
​
   Приклади
   Вхідні дані: nums1 = 1,2,3, nums2 = 1,2,3,4
   Результат: True
   Пояснення: Всі елементи nums1 ([1,2,3]) присутні в nums2.
​
   Вхідні дані: nums1 = [2,4], nums2 = [1,2,3,4]
   Результат: False
   Пояснення: Елементи nums1 ([2,4]) не знаходяться в тому ж порядку в nums2.
​
   Вхідні дані: nums1 = [1,3,5], nums2 = [1,2,3,4,5]
   Результат: True
   Пояснення: Елементи nums1 ([1,3,5]) присутні в nums2.
​
   Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
'''

***
### Лабораторна робота №2 (Варіант 3 Рівень 1)

''' 
    Ви граєте в альтернативний варiант покеру, де кожен гравець має в руках N карт, i
    метою гри є набрати якомога довшу групу послiдовних карт.
    Колода складається з карт, якi мають числову величину. Також, в колодi присутнi
    джокери. Якщо в руцi гравця є джокери, вiн може присвоїти кожному будь-яку
    величину на власний розсуд.
    Вам роздали карти. Визначте довжину найдовшої послiдовностi карт, яку ви можете
    скласти.
​
    Вхiднi данi
    масив цiлих чисел вiд 0 до 1000000 включно — величини окремих карт в
    руцi. Загальна кiлькiсть карт в руцi не перевищує 10000.
    Джокери позначаються величиною 0.
​
    Перехiд через верхню межу» не дозволяється — `[999999, 1000000, 1, 2]` не вважається
    коректною послiдовнiстю.
​
    Ваша функція має повертати довжину найдовшої послiдовної групи, яку можна скласти з виданих карт.
​
    Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
​
    Приклад 1
    cards = 0 10 15 50 0 14 9 12 40
​
    Результат
    7
    Пояснення: Можна замiнити один джокер на 11, iнший — на 13, i скласти таку
    послiдовнiсть: 9, 10, 11, 12, 13, 14, 15.
​
    Приклад 2
    cards =1 1 1 2 1 1 3
    Результат
    3
​
    Приклад 3
    cards = 5 6 5 6 5 6 5 6 5 6 5 0 0
    Результат
    4
​
    Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` та перевірити роботу вашої функції на прикладах, наведених вище
'''

***
### Лабораторна робота №3 (Варіант 3 Рівень 2)

'''
    Напишіть функцію, яка виконає операцію інвертування (перевернення) бінарного дерева таким чином, щоб лівий дочірній вузол став правим, а правий дочірній вузол став лівим.

   Нехай у вас задане бінарне дерево такого вигляду:
 
        1
       / \
      2   3
     / \ / \
    4  5 6  7
    Ваша функція має повернути дерево, яке виглядатиме наступним чином:

       1
      / \
     3   2
    / \ / \
   7  6 5  4
   Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:


   class BinaryTree:
     def __init__(self, value: int):
        self.value = value
        self.left = None
        self.right = None
    Ваша функція має мати такий вигляд:

   def invert_binary_tree(tree) -> BinaryTree:
   Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:

   root = BinaryTree(3)
   root.left = BinaryTree(9)
   root.right = BinaryTree(20)
   Ваша функція має повернути об'єкт класу BinaryTree. Для спрощення тестування даної функції достатньо реалізувати порівняння значень вузлів дерева
'''
***

### Лабораторна робота №4 (Варіант 3 Рівень 2)

'''
   Дано двійкове дерево, знайти його мінімальну глибину. Мінімальна глибина — це загальна кількість вузлів уздовж найкоротшого шляху від кореневого вузла до найближчого кінцевого вузла.

  Наприклад, мінімальна глибина наступного бінарного дерева дорівнює 3. Найкоротший шлях — 1 —> 3 —> 6.


                                        1
                                       / \
                                      2   3
                                     / \  / \
                                    4  5  6  7
                                     \  \    / \ 
                                     8  9   10 11
                                      \ 
                                      12
  Для представлення графу слід використати список суміжності,дані зчитуються з файлу input.txt

  input.txt містить:
  1 #корінь дереа
  1,2 # список ребер, де порядок вершин визначає напрямок. В даному випадку ребро направлене від 1 до 2
  1,3
  2,4

  Результат (мінімальна глибина дерева) слід вивести у файл output.txt


'''

***